#require-relative 'min_heap'
require 'algorithms'

include Containers

class MyHuffman

=begin
  For this part, I got this part from Justen who got it from Dr. Johnson.
  Count the frequencies of the characters in the string that and return a Hash
  with characters as keys and frequencies as values. Remember that you need to count whitespace characters
  (like spaces) and punctuation marks as characters.
  PARAMETER IS A string
=end
  def count_frequencies(string)
    hash = Hash.new  #initialize hash
    string.each_char do |j| #get the chars of the letters also known as for loop, j is the key
      if(hash.has_key?(j))#if chars has this keys
        hash[j] +=1    # increment that Hash
      else
        hash[j] = 1 #add it to the hash
      end       #end statment for if statment
    end        # end statment for for loop of string.each_char do |j|
    hash  #return the hash
  end          # end statment for the method count_frequencies

=begin
  For this part, I got this part from Justen who got it from Dr. Johnson.
  This method will take the hash generated by the count frequencies method and use it
  to build an encoding tree using the algorithm listed on page 1.
  PARAMETER IS A Hash
=end
  def huffman(hash)
    mini = MinHeap.new # Created a MinHeap
    hash.each_key do |s| #for loop for each key of my hash calling it, s is the key
      binary = BinarySearchTree.new(s,nil, nil) #initializing a BinarySearchTree with value at s with child that are null
      mini.push([hash[s], binary]) # pushing the mini with hash of s and tree that was created, binary is the tree object that
      #stores the character like "A, B, C", hash[s] gets the value of that hash like number 1,2 3
      end # end statment for the loop
      while mini.size > 1 do # starting my while loop for mini of the size is greater than 1
        f1 = mini.pop #both finding the minkey and removeMin at same time
        f2 = mini.pop #both finding the minkey and removeMin at same time
        value =f1[0] + f2[0]
        tree = BinarySearchTree.new(value,f1[1],f2[1]) #create a new binary tree T with Left subtree T1 and right subtree t2
        mini.push([value,tree])  #Insert T into Q with key f1 + f2
      end # end of the while loop
      tree #return the tree of the values and keys
end # end statment for def huffman

=begin
  For this part, I got this part from Justen who got it from Dr. Johnson.
 This is the tree_traversal for the encode_string to help write it out.
=end

def tree_traversal(t, str, h)
  if(t.left.left != nil) #if the tree left left value is not null
    tree_traversal(t.left, str + '0', h) #calling the method with left child, code stirng and code hash
  else
  #  puts str
    h[t.left.key] = str + '0' #  code hash of the the child child +0
  end # end statment for left Part
  if(t.right.right !=nil) #if the tree right left value is not null
    tree_traversal(t.right, str +'1', h)#calling the method with left child, code stirng and code hash
  else
  # puts str
    h[t.right.key] = str +'1' #code hash of the the right child +1
  end # end statment for right Part
  h
end

=begin
  For this part, I got this part from Justen who got it from Dr. Johnson.
  This method will use the tree you generated with the huffman method
  (or any other encoding tree) to encode the string that you use as the second argument. Output the encoding
  as a string consisting of 1’s and 0’s.
  PARAMETER IS A TREE AND string
=end

  def encode_string(tree,string)
    newhash = Hash.new #declare a new hash
    newstring = String.new #delcare a new stirng
    finalstring = String.new
    h2 = tree_traversal(tree,newstring,newhash)# call tree_traversal for each characters
    #blah = { 'a'=>"01", 'b'=>"1", 'c'=>"11"}
  #  puts h2
    string.each_char do |a| # for each character in the string, add that characters stirng value
      #to the encoded string

    #  puts h2

      finalstring << h2[a] #appending the string into
    end # end statment for loop
    finalstring #return the string
  end #end statment for encode_string
end# this is the end statment of the class
